Networking is a fundamental part of system design: you're nearly always going to be designing systems comprised of independent devices that communicate over a network. 
Networking 101
At its core, networking is about connecting devices and enabling them to communicate. Networks are built on a layered architecture (the so-called "OSI model") which greatly 
simplifies the world for us application developers who sit on top of it.
Networking Layers
Network Layer (Layer 3):- ("postal routing system") Its main goal: figure out how to send data from one device to another ‚Äî possibly across multiple networks.
1. When your computer sends a message (like a file or a web request), IP doesn‚Äôt send it all at once. It divides the data into smaller units called packets, 
   each of which can travel separately through the network.
2. Every device on a network has an IP address (like 192.168.1.1 or 2400:da00::1 for IPv6).
3. IP works with routers ‚Äî special devices that figure out the best path to send packets to reach their destination, even if the destination is on a completely different network.
4. IP is not guaranteed to deliver every packet ‚Äî it‚Äôs a best-effort protocol. This means it will try to deliver data but won‚Äôt check for packet loss or order. If packets get dropped 
   or arrive out of order, higher layers (like TCP) handle fixing that.
Transport Layers
The Network Layer (Layer 3) gets your data across networks ‚Äî it figures out how to reach the destination.
But once your data arrives at the destination machine, how does it reach the right process/app?
That‚Äôs the Transport Layer‚Äôs job.
It ensures reliable, ordered, and application-specific delivery of messages between two endpoints (like between your browser and a web server).
1. üß± TCP (Transmission Control Protocol)
‚Üí Reliable, ordered, connection-oriented protocol
üöó Analogy:
Like a reliable courier service that:
Calls before pickup (connection setup)
Tracks every parcel (acknowledgment)
Resends any lost parcel
Delivers in order
2. üöÄ UDP (User Datagram Protocol)
‚Üí Fast, connectionless, unreliable protocol
üöó Analogy: Like sending postcards ‚Äî each one travels separately, and if one is lost, you just move on.
3. ‚ö° QUIC (Quick UDP Internet Connections)
‚Üí Modern protocol built on top of UDP
Why QUIC was created:
1. TCP is reliable but slow due to:
2. Connection setup (3-way handshake)
3. Head-of-line blocking (waiting for missing packets)
4. TLS encryption happening separately
QUIC solves this by:
üåÄ Combining TLS encryption + transport in one layer (faster handshake)
‚ö° Built on UDP, so it‚Äôs connectionless but still reliable & ordered
üöÄ Provides multiplexing (multiple streams in one connection)
üîÑ Allows connection migration ‚Äî your session stays alive even if your IP changes (e.g., switching from WiFi to mobile data)
‚ö° Example: When you load a website using HTTP/3, it‚Äôs actually using QUIC under the hood ‚Äî faster, secure, and resilient.
üöó Analogy: Like an express delivery service that‚Äôs as fast as UDP but as reliable as TCP ‚Äî with built-in security and no traffic jams.

üß† Easy way to remember:
Transport Layer ‚Üí ‚ÄúSplit message so receiver can understand it correctly.‚Äù
Network Layer ‚Üí ‚ÄúFigure out how and where to send each piece
| Layer       | Name            | Main Protocols | Focus                                                                       |
| ----------- | --------------- | -------------- | --------------------------------------------------------------------------- |
| Layer 3     | Network Layer   | IP             | Getting data to the right machine                                           |
| Layer 4     | Transport Layer | TCP, UDP, QUIC | Getting data to the right process on that machine, reliably and efficiently |

‚úÖ How Transport layer protocol is decided?
So ‚Äî you decide at the application layer (like HTTP, WebSocket, or WebRTC).
Each of those automatically defines which transport protocol (TCP/UDP/QUIC) it uses under the hood.
| Type of App            | Common Protocol           | Uses Which Transport Layer Protocol |
| ---------------------- | ------------------------- | ----------------------------------- |
| Website                | **HTTP / HTTPS**          | ‚úÖ TCP (or QUIC for HTTP/3)         |
| API Server             | **REST (HTTP)**           | ‚úÖ TCP                              |
| Chat / Messaging       | **WebSocket (over HTTP)** | ‚úÖ TCP                              |
| Video Call / Streaming | **RTP / WebRTC**          | ‚ö° UDP                               |
| Email                  | **SMTP / IMAP**           | ‚úÖ TCP                              |
| DNS Lookup             | **DNS**                   | ‚ö° UDP                               |

| Who Decides What                       | Example                                                                         |
| -------------------------------------- | ------------------------------------------------------------------------------- |
| **You (Developer)**                    | Pick the **application layer** (e.g., HTTP, WebSocket, DNS, WebRTC)             |
| **Protocol Specification**             | Defines the **transport layer** (e.g., HTTP ‚Üí TCP, WebRTC ‚Üí UDP)                |
| **Operating System**                   | Handles the **network layer (IP)** and below automatically                      |
| **You rarely choose TCP/UDP manually** | Unless you‚Äôre writing a **custom socket app** (e.g., game server or IoT system) |

Application Layer (Layer 7)
At the final layer are the application protocols like DNS, HTTP, Websockets, WebRTC. These are common protocols that build on top of TCP (or UDP, in the case of WebRTC) to provide 
a layer of abstraction for different types of data typically associated with web applications.

Example: A Simple Web Request
When you type a URL into your browser, several layers of networking protocols spring into action. Let's break down how these layers work together to retrieve a simple web page over HTTP on TCP.
First, we use DNS to convert a human-readable domain name like hellointerview.com into an IP address like 32.42.52.62. Then, a series of carefully orchestrated steps begins. We set up a TCP connection over IP, send our HTTP request, get a response, and tear down the connection.
In detail:

‚úÖ Simple HTTP Request
1. DNS Resolution: The client starts by resolving the domain name of the website to an IP address using DNS (Domain Name System).
2. TCP Handshake: The client initiates a TCP connection with the server using a three-way handshake:
    SYN: The client sends a SYN (synchronize) packet to the server to request a connection.
    SYN-ACK: The server responds with a SYN-ACK (synchronize-acknowledge) packet to acknowledge the request.
    ACK: The client sends an ACK (acknowledge) packet to establish the connection.
3. HTTP Request: Once the TCP connection is established, the client sends an HTTP GET request to the server to request the web page.
4. Server Processing: The server processes the request, retrieves the requested web page, and prepares an HTTP response. (This is usually the only latency most SWE's think about and control!)
5. HTTP Response: The server sends the HTTP response back to the client, which includes the requested web page content.
6. TCP Teardown: After the data transfer is complete, the client and server close the TCP connection using a four-way handshake:
    FIN: The client sends a FIN (finish) packet to the server to terminate the connection.
    ACK: The server acknowledges the FIN packet with an ACK.
    FIN: The server sends a FIN packet to the client to terminate its side of the connection.
    ACK: The client acknowledges the server's FIN packet with an ACK.

What kind of connection chat application used
1Ô∏è‚É£ HTTP Keep-Alive (HTTP/1.1)
Normally, HTTP/1.1 closes the connection after every request-response.
Keep-Alive keeps the TCP connection open for multiple requests.
Reduces the overhead of re-establishing TCP connections.
‚úÖ Good for frequent short requests, like fetching multiple resources from a website.
‚ö†Ô∏è Still not ideal for real-time chat, because:
You‚Äôd need to poll the server repeatedly to get updates.
Even with Keep-Alive, HTTP is still request-response, not truly bi-directional.

2Ô∏è‚É£ HTTP/2 Multiplexing
HTTP/2 allows multiple requests/responses to share a single TCP connection concurrently.
Reduces latency compared to HTTP/1.1, because you don‚Äôt need multiple TCP connections for multiple resources.
‚úÖ Good for web apps with lots of assets or API calls.
‚ö†Ô∏è Still request-response: the server can‚Äôt push real-time messages to the client easily (without special server push features).

3Ô∏è‚É£ Why chat apps don‚Äôt rely on them
Chat apps need server-initiated messages: the server must be able to push messages instantly.
HTTP/1.1 or HTTP/2 alone don‚Äôt naturally allow the server to push data whenever it wants (HTTP/2 has server push, but it‚Äôs designed for resources, not arbitrary events like chat messages).
So most chat apps use:
WebSockets (over TCP) ‚Üí truly bi-directional, persistent connection.
MQTT or XMPP (over TCP) ‚Üí lightweight, persistent, real-time messaging.

The Dynamic Host Configuration Protocol (DHCP) is a network management protocol used on Internet Protocol (IP) networks for automatically assigning IP addresses and other communication parameters to devices connected to the network using a client‚Äìserver architecture.
