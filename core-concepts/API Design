 🧩 1. API Design in System Design Interviews

 Define how clients interact with your system.
 Keep it short (~5 min) — show good judgment, not perfection.
 For frontend/product/junior roles, API design matters more.



 ⚙️ 2. Common API Types

(a) REST — Default choice

 Uses HTTP verbs (GET, POST, PUT, PATCH, DELETE).
 Maps well to CRUD and database operations.
 Well-understood, best for 90% of cases.

(b) GraphQL

 Single endpoint, client defines data shape.
 Solves over-fetching/under-fetching issues.
 Best for diverse clients (mobile/web).
 Adds complexity (schema, resolvers, caching).

(c) RPC / gRPC

 Action-based (e.g., `createBooking()`).
 High performance, binary serialization (Protocol Buffers + HTTP/2).
 Ideal for internal microservice communication.

👉 Default to REST unless explicitly told otherwise.



 🔗 3. REST Design Basics

a. Resource Modeling

 Identify core entities (e.g., events, venues, bookings).
 Use plural nouns (`/events`, `/bookings`).
 Nest when relationship is required: `/events/{id}/tickets`.
 Use query params for optional filters: `/tickets?event_id=123`.

b. HTTP Methods

| Method | Purpose        | Idempotent? |
|  | -- | -- |
| GET    | Read           | ✅           |
| POST   | Create         | ❌           |
| PUT    | Replace        | ✅           |
| PATCH  | Partial Update | ✅           |
| DELETE | Remove         | ✅           |

 Understand idempotency — retries shouldn’t cause duplicates.

c. Passing Data

| Location     | Purpose              | Example              |
|  | -- | -- |
| Path Params  | Required resource ID | `/events/123`        |
| Query Params | Optional filters     | `/events?city=NYC`   |
| Request Body | Main payload         | Booking details JSON |

d. Returning Data

 Use JSON + proper HTTP status codes (200, 201, 400, 401, 404, 500).
 Know 4xx = client errors, 5xx = server errors.



 🧠 4. GraphQL Basics

 One endpoint (`/graphql`) handles flexible queries.
 Client specifies exactly what fields it needs.
 Great for multi-client systems (mobile/web).
 Watch for N+1 query problem → solve using batching/dataloaders.
 Authorization often at field level.
 Use when interviewer mentions flexible fetching or multiple clients.



 ⚡ 5. RPC (gRPC) Basics

 Procedure-oriented → remote function calls.
 Define `.proto` files → generate client/server code.
 Fast, type-safe, supports streaming.
 Use internally between microservices (not for public APIs).



 🔁 6. Common API Patterns

a. Pagination

 Offset-based: `/events?offset=20&limit=10` (simple, can shift).
 Cursor-based: `/events?cursor=abc&limit=10` (stable for real-time).
 Mention pagination to show scalability awareness.

b. Versioning

 URL versioning: `/v1/events` (clear, simple).
 Header versioning: `API-Version: 2` (cleaner but less visible).
 In interviews → use URL versioning.



 🔒 7. Security Considerations

a. Authentication vs Authorization

 AuthN → Who are you?
 AuthZ → What are you allowed to do?

b. API Keys

 Used for server-to-server or 3rd-party access.
 Stored/validated by backend.

c. JWT Tokens

 Used for user sessions (web/mobile).
 Self-contained (no DB lookup), includes user info + expiry.

d. RBAC (Role-Based Access Control)

 Define roles and restrict endpoints accordingly.

e. Rate Limiting / Throttling

 Prevent abuse (e.g., 1000 req/hr per user).
 Return `429 Too Many Requests` when exceeded.

Pagination
When you're dealing with large datasets, you can't return everything at once. Imagine an API that returns all events ever created, that could be millions of records which would be many gigabytes of data.
Instead, you need pagination to break large result sets into manageable chunks. There are two main approaches to pagination: offset-based and cursor-based.
✅ Offset-based Pagination
Offset-based pagination is the simplest approach and used by most websites. 
You specify how many records to skip and how many to return: /events?offset=20&limit=10 gets records 21-30. 
This is intuitive and easy to implement, but it has problems with large datasets. 
If someone adds a new event while you're paginating through results, you might see duplicates or miss records as the data shifts.
✅ Cursor-based Pagination
Cursor-based pagination solves this by using a pointer to a specific record instead of counting from the beginning. 
Here's how it works in practice:
First request: /events?limit=10
Response includes the events plus a cursor pointing to the last record:
{
  "events": [...],
  "next_cursor": "cmd9atj3p000007ky19w1dpy2"
}
Next request: /events?cursor=cmd9atj3p000007ky19w1dpy2&limit=10
The cursor is typically an encoded reference to a specific record (like an ID or timestamp). This is more stable because it's not affected by new records being added, but it's harder to implement features like "jump to page 5." In the example, cmd9atj3p000007ky19w1dpy2 is the id of the last event in the first page.
For interviews, offset-based pagination is usually fine unless you're dealing with real-time data or the interviewer specifically asks about high-volume scenarios. Most interviewers care more about whether you remembered to include pagination than which specific approach you choose.

Other Real-Life Examples
Train Ticket Counter
Offset-based: “Give me the 101st to 110th customer” → if someone skips the line, your numbers are off.
Cursor-based: “Give me the 10 customers after this ticket number X” → stable, doesn’t matter who jumped in or out.
Email Inbox Scroll
Offset: “Show emails 21–40” → new emails could push old emails to a different position.
Cursor: “Show emails after ID 12345” → exact next batch, no duplicates, no skipping.

 🧭 8. Interview Strategy
 Spend ≤ 5 minutes on APIs.
 Show:
   You can design logical endpoints.
   You know REST basics.
   You’re aware of security and scalability (pagination, versioning, rate limits).
 Don’t over-optimize; focus on reasoning and clarity.
