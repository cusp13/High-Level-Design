
https://medium.com/@jramcloud1/the-internal-structure-of-postgresql-a-deep-dive-into-how-postgresql-organizes-data-7a0952ec0569

âœ… Autovacuum does not run constantly.
Each table has a few thresholds that trigger a vacuum cycle:

ğŸ“Š Conditions Checked
PostgreSQL checks roughly:
vacuum_threshold = autovacuum_vacuum_threshold + autovacuum_vacuum_scale_factor * number_of_live_rows
autovacuum_vacuum_threshold â†’ default 50
autovacuum_vacuum_scale_factor â†’ default 0.2 (20%)
number_of_live_rows â†’ estimated number of tuples in the table

So, for example:
If a table has 100,000 rows â†’
Autovacuum runs when ~20,050 rows are dead.
(50 + 0.2 Ã— 100,000)
Thatâ€™s how PostgreSQL decides when to vacuum.


Now:
When you UPDATE a row â†’ PostgreSQL sets the old rowâ€™s xmax to the new transaction ID.
But it doesnâ€™t immediately mark it dead.
The tuple is only considered dead once no active transaction could possibly see it anymore.
That means:
If some long-running transaction started before the update â†’ that transaction can still â€œseeâ€ the old row (due to MVCC rules).
So PostgreSQL keeps the old version alive until that transaction finishes.
So:
âœ… â€œNot marked as deadâ€ = still visible (to some transaction, snapshot, or in-progress query).
ğŸ§¹ Only when all possible snapshots move past it â†’ autovacuum can clean it.

row is not dead if some transaction can still see it (MVCC visibility rule).

FSM lookup is lightweight; PostgreSQL only appends when no reusable space is found â€” no latency concern in practice.


âš™ï¸ Two Types (Advanced Insight)

Regular View (Virtual View) â†’ Runs query on demand; no data stored.

Materialized View â†’ Stores query result physically; needs refresh manually.

ğŸ‘‰ Analogy:

View = freshly cooked dish every time ğŸ³

Materialized View = pre-cooked, stored in the fridge ğŸ§Š (faster but can become stale)
